/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2013-2015. All rights reserved.
 * Description: shell cmds APIs implementation
 * Author: none
 * Create: 2013
 */

#include "lwip/priv/nd6_priv.h"
#include "lwip/sockets.h"
#include "lwip/inet_chksum.h"
#include "lwip/raw.h"
#include "lwip/priv/api_msg.h"
#include "lwip/icmp.h"
#include "lwip/dns.h"
#include "lwip/netdb.h"
#include "lwip/ip.h"
#include "los_config.h"
#include <string.h>
#include "limits.h"
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <ctype.h>
#if LWIP_LITEOS_TASK
#include "hi_time.h"
#endif
#ifdef LOSCFG_SHELL
#include "shcmd.h"
#include "shell.h"
#endif
#include "lwip/api_shell.h"

#ifdef CUSTOM_AT_COMMAND
#include "hi_at.h"
#endif

#if LWIP_ENABLE_BASIC_SHELL_CMD

#ifdef CUSTOM_AT_COMMAND
#define LWIP_PING_TASK_PRIO 5
#define LWIP_PING_MAX_PKT_LEN 7360
#else
#define LWIP_PING_TASK_PRIO 4
#endif

#define LWIP_PING_INTERFACE_ARG       1
#define LWIP_PING_HOSTNAME_ARG        2
#define LWIP_PING_DEFAULT_SOCKET      4
#define PERCENT 100

/* Maximum tick value that can be generated by sys_now() */
#define LWIP_MAX_TICK                 0xFFFFFFFF
#define LWIP_TICK_SIZE                sizeof(u32_t)
#define LWIP_MAX_TICK_U64             0xFFFFFFFFFFFFFFFFLLU

static UINT32 ping_taskid = 0;
static int ping_kill = 0;
#define PING_ZERO_DATA_LEN 8
static void
lwip_ping_usage(u32_t is_v6)
{
#ifndef CUSTOM_AT_COMMAND
  char *ping = is_v6 ? "ping6" : "ping";
  PRINTK("Usage:"\
         CRLF"  %s"
         CRLF"  %s [-6] [-n cnt] [-w interval] [-l data_len] destination"
         CRLF"  %s [-I iface/ipaddress] [-t] [-w interval] [-W timeout] destination"
         CRLF"  %s -k", ping, ping, ping, ping);
  PRINTK(CRLF"  -t means ping forever, user can use -k to stop the forever ping");
#else
  (void)is_v6;
#endif
}

struct ping_run_ctx {
  int sfd;
  u32_t is_v6;
  struct sockaddr_storage to;
  struct icmp_echo_hdr *iecho;
  struct icmp_echo_hdr *iecho_resp;
  struct ip_hdr *iphdr_resp;
  u32_t iecho_len;
  s16_t ip_hlen;
  u16_t i;
  u32_t forever;
  u32_t succ_cnt;
  u32_t failed_cnt;
#if LWIP_LITEOS_TASK
  u64_t start_us;
  u64_t end_us;
  u64_t timout_end_us;
#else
  u32_t start_ms;
  u32_t end_ms;
  u32_t timout_end_ms;
#endif

#ifdef CUSTOM_AT_COMMAND
  s32_t rtt_sum;
  s32_t rtt_min;
  s32_t rtt_max;
#endif

  s32_t timout_ms;
#if LWIP_SOCKET_POLL
  struct pollfd pfd;
#else
  fd_set read_set;
  struct timeval time_val;
#endif
  s32_t rtt;
  u32_t intrvl;
  char *data_buf;
  struct sockaddr_storage dst;
  u32_t socklen;
  u32_t cnt;
  u32_t timout;
  u32_t interval;
  u32_t data_len;
};

#define PING_ADDR_STR_LEN 32

struct ping_cfg {
  u32_t count;
  u32_t interval;
  u32_t timeout;
  u32_t data_len;
  struct sockaddr_storage dst;
  u8_t src_type;
  u32_t is_v6;
  char src_iface[IFNAMSIZ];
  struct sockaddr_storage src;
};

LWIP_STATIC void
ping_req_init(struct ping_run_ctx *ctx)
{
  u32_t i;
  if (ctx->data_len > PING_ZERO_DATA_LEN) {
    (void)memset_s(ctx->iecho, sizeof(struct icmp_echo_hdr) + PING_ZERO_DATA_LEN, 0,
                   sizeof(struct icmp_echo_hdr) + PING_ZERO_DATA_LEN);
    ctx->data_buf = (char *)ctx->iecho + sizeof(struct icmp_echo_hdr) + PING_ZERO_DATA_LEN;
    for (i = 0; i < ctx->data_len - PING_ZERO_DATA_LEN; i++) {
      *(ctx->data_buf + i) = i + 0x10;
    }
  } else {
    (void)memset_s(ctx->iecho, sizeof(struct icmp_echo_hdr) + ctx->data_len, 0,
                   sizeof(struct icmp_echo_hdr) + ctx->data_len);
  }
  ctx->iecho->id = LWIP_RAND();

#if LWIP_IPV6
  if (ctx->is_v6) {
    ICMPH_TYPE_SET(ctx->iecho, (u8_t)ICMP6_TYPE_EREQ);
  } else
#endif
  {
    ICMPH_TYPE_SET(ctx->iecho, (u8_t)ICMP_ECHO);
  }
}

LWIP_STATIC int
ping_ctx_init(struct ping_run_ctx *ctx, struct ping_cfg *cfg)
{
  ctx->sfd = -1;
  ctx->is_v6 = cfg->is_v6;
  ctx->iecho = NULL;
  ctx->iecho_resp = NULL;
  ctx->iphdr_resp = NULL;
  ctx->succ_cnt = 0;
  ctx->failed_cnt = 0;

#ifdef CUSTOM_AT_COMMAND
  ctx->rtt_sum = 0;
  ctx->rtt_min = 0;
  ctx->rtt_max = 0;
#endif
  ctx->data_buf = NULL;
  ctx->dst = cfg->dst;
#if LWIP_IPV6
  ctx->socklen = (ctx->dst.ss_family == AF_INET) ? sizeof(struct sockaddr_in) : sizeof(struct sockaddr_in6);
#else
  ctx->socklen = sizeof(struct sockaddr_in);
#endif
  ctx->cnt = cfg->count;
  ctx->interval = cfg->interval;
  ctx->timout = cfg->timeout;
  ctx->data_len = cfg->data_len;

  ctx->iecho_len = sizeof(struct icmp_echo_hdr) + ctx->data_len;
  ctx->iphdr_resp = (struct ip_hdr *)mem_malloc(ctx->iecho_len + IP_HLEN_MAX);
  if (ctx->iphdr_resp == NULL) {
#ifdef CUSTOM_AT_COMMAND
    (void)hi_at_printf("Ping: pbuf_resp malloc failed"CRLF);
#else
    PRINTK("Ping: pbuf_resp malloc failed"CRLF);
#endif
    return -1;
  }
  ctx->iecho = (struct icmp_echo_hdr *)mem_malloc(ctx->iecho_len);
  if (ctx->iecho == NULL) {
#ifdef CUSTOM_AT_COMMAND
    (void)hi_at_printf("Ping: echo request malloc failed"CRLF);
#else
    PRINTK("Ping: echo request malloc failed"CRLF);
#endif
    return -1;
  }
  ctx->to = cfg->dst;
  ctx->forever = (ctx->cnt ? 0 : 1);
  ctx->i = 0;
  ping_req_init(ctx);
  return 0;
}


LWIP_STATIC void
ping_resp_code_print(u8_t iecho_resp)
{
  const char *print_str = NULL;
  LWIP_STATIC const char *icmp_code_str[] = {
    "icmp reply", /* ICMP_ER */
    NULL,
    NULL,
    "destination host unreachable", /* ICMP_DUR */
    "source quench", /* ICMP_SQ */
    "redirect", /* ICMP_RD */
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    "time exceeded", /* ICMP_TE */
    "parameter problem" /* ICMP_PP */
  };

  if (iecho_resp < LWIP_ARRAYSIZE(icmp_code_str)) {
    print_str = icmp_code_str[iecho_resp];
  }

  if (print_str == NULL) {
    print_str = "unknow error";
  }
#ifdef CUSTOM_AT_COMMAND
  (void)hi_at_printf("Ping: %s ..."CRLF, print_str);
#else
  PRINTK("Ping: %s ..."CRLF, print_str);
#endif
}

LWIP_STATIC void
ping_resp_process(struct ping_run_ctx *ctx)
{
  u8_t af = AF_INET;
  const char *ipstr = NULL;
  char str_buf[PING_ADDR_STR_LEN];
  const void *src = &(((struct sockaddr_in *)&ctx->to)->sin_addr);

#if LWIP_IPV6
  if (ctx->is_v6) {
    af = AF_INET6;
    src = &(((struct sockaddr_in6 *)&ctx->to)->sin6_addr);
  }
#endif
  ipstr = lwip_inet_ntop(af, src, str_buf, PING_ADDR_STR_LEN);
  if (ipstr == NULL) {
    ipstr = "****";
  }

#ifdef CUSTOM_AT_COMMAND
#if LWIP_IPV6
  if (ctx->is_v6) {
    (void)hi_at_printf("%u bytes from %s: icmp_seq=%u ", ctx->data_len, ipstr, ctx->i);
    if (ctx->rtt < 1) {
      (void)hi_at_printf("time<1ms"CRLF);
    } else {
      (void)hi_at_printf("time=%ims"CRLF, ctx->rtt);
    }
  } else
#endif
  {
    (void)hi_at_printf("[%u]Reply from %s:", ctx->i, ipstr);
    if (ctx->rtt < 1) {
      (void)hi_at_printf("time<1ms ");
    } else {
      (void)hi_at_printf("time=%dms ", ctx->rtt);
    }
    (void)hi_at_printf("TTL=%u"CRLF, ctx->iphdr_resp->_ttl);
  }
#else
  PRINTK("[%u]Reply from %s: ", ctx->i, ipstr);
  if (ctx->rtt < 1) {
    PRINTK("time<1 ms ");
  } else {
    PRINTK("time=%i ms ", ctx->rtt);
  }
  if (ctx->is_v6 == 0) {
    PRINTK("TTL=%u"CRLF, ctx->iphdr_resp->_ttl);
  } else {
    PRINTK(CRLF);
  }
#endif

  /* delay 1s for every successful ping */
  ctx->intrvl = ctx->interval;
  if (((ctx->succ_cnt + ctx->failed_cnt + 1) < ctx->cnt) || ctx->forever) {
    do {
      if (ctx->intrvl < MS_PER_SECOND) {
        sys_msleep(ctx->intrvl);
        break;
      }
      ctx->intrvl -= MS_PER_SECOND;
      sys_msleep(MS_PER_SECOND);
      if (ping_kill == 1) {
        break;
      }
    } while (ctx->intrvl > 0);
  }
  ctx->succ_cnt++;
#ifdef CUSTOM_AT_COMMAND
  if (ctx->rtt >= 1) {
    ctx->rtt_sum += ctx->rtt;
  }
  if ((ctx->rtt < ctx->rtt_min) || (ctx->succ_cnt == 1)) {
    ctx->rtt_min = ctx->rtt;
  }
  if ((ctx->rtt > ctx->rtt_max) || (ctx->succ_cnt == 1)) {
    ctx->rtt_max = ctx->rtt;
  }
#endif
}

LWIP_STATIC void
ping_rcv_rtt_calc(struct ping_run_ctx *ctx)
{
#if LWIP_LITEOS_TASK
  ctx->timout_end_us = hi_get_us();
  if (ctx->timout_end_us < ctx->start_us) {
    /* Incase of wraparoud of ticks */
    ctx->rtt = (s32_t)(ctx->timout_end_us / US_PER_MSECOND + ((LWIP_MAX_TICK_U64 - ctx->start_us) / US_PER_MSECOND));
  } else {
    ctx->rtt = (s32_t)(ctx->timout_end_us / US_PER_MSECOND - ctx->start_us / US_PER_MSECOND);
  }
#else
  ctx->timout_end_ms = sys_now();
  ctx->rtt = (s32_t)(ctx->timout_end_ms - ctx->start_ms);
  if (ctx->rtt < 0) {
    ctx->rtt = (s32_t)(ctx->timout_end_ms + (LWIP_MAX_TICK - ctx->start_ms));
  }
#endif
}

LWIP_STATIC const char *convert_icmpv6_err_to_string(u8_t err_type)
{
  switch (err_type) {
    case ICMP6_TYPE_DUR:
      return "Destination Unreachable";
    case ICMP6_TYPE_PTB:
      return "Packet too big";
    case ICMP6_TYPE_TE:
      return "Time Exceeded";
    case ICMP6_TYPE_PP:
      return "Parameter Problem";
    default:
      break;
  }
  return NULL;
}

LWIP_STATIC int
ping_rcv_check(struct ping_run_ctx *ctx, int len)
{
#if LWIP_IPV6
  int ip_hlen_min = ctx->is_v6 ? 0 : IP_HLEN;
#else
  int ip_hlen_min = IP_HLEN;
#endif

  if ((u32_t)len < sizeof(struct icmp_echo_hdr) + ip_hlen_min) {
#ifdef CUSTOM_AT_COMMAND
    /* Drop the packet if its too short [Doesnot contain even the header !!] */
    PRINTK("ping: received ICMP echo response too short for less icmp header\n");
#else
    perror("Ping: received ICMP echo response too short for less icmp header\n");
#endif
    return -1;
  }

  /* Accessing ip header and icmp header */
#if LWIP_IPV6
  ctx->ip_hlen = ctx->is_v6 ? 0 : (IPH_HL(ctx->iphdr_resp) << 2);
#else
  ctx->ip_hlen = (IPH_HL(ctx->iphdr_resp) << 2);
#endif
  if ((u32_t)len < sizeof(struct icmp_echo_hdr) + ctx->ip_hlen) {
#ifdef CUSTOM_AT_COMMAND
    /* Drop the packet if its too short [Doesnot contain send len !!] */
    PRINTK("ping : received ICMP echo response too short for not equal send len\n");
#else
    perror("Ping: received ICMP echo response too short for not equal send len\n");
#endif
    return -1;
  }

#if LWIP_IPV6
  if (ctx->is_v6) {
    ctx->iecho_resp = (struct icmp_echo_hdr *)((char *)ctx->iphdr_resp);
  } else
#endif
  {
    struct sockaddr_in *sin = (struct sockaddr_in *)&ctx->to;
    if (sin->sin_addr.s_addr != ctx->iphdr_resp->src.addr) {
      return -1;
    }
    ctx->iecho_resp = (struct icmp_echo_hdr *)((char *)ctx->iphdr_resp + ctx->ip_hlen);
  }

#if LWIP_IPV6
  if (ctx->is_v6) {
     if (ICMPH_TYPE(ctx->iecho_resp) != ICMP6_TYPE_EREP) {
        const char *err_str = convert_icmpv6_err_to_string(ICMPH_TYPE(ctx->iecho_resp));
        if (err_str != NULL) {
#ifdef CUSTOM_AT_COMMAND
          (void)hi_at_printf("ping: %s"CRLF, err_str);
#else
          PRINTK("ping: %s"CRLF, err_str);
#endif
        }
        return -1;
     }
  } else
#endif
  {
    if (ICMPH_TYPE(ctx->iecho_resp) == ICMP_ECHO) {
      /* skip loopback ICMP_ECHO */
      return -1;
    } else if (ICMPH_TYPE(ctx->iecho_resp) != ICMP_ER) {
      ping_resp_code_print(ICMPH_TYPE(ctx->iecho_resp));
      return -1;
    }
  }

  if (ctx->iecho_resp->id != ctx->iecho->id) {
#ifdef CUSTOM_AT_COMMAND
    (void)hi_at_printf("Ping : recv id unmatch"CRLF);
#else
    PRINTK("Ping: recv id unmatch %u %u"CRLF, ctx->iecho_resp->id, ctx->iecho->id);
#endif
    return -1;
  }

  if (ntohs(ctx->iecho_resp->seqno) != ctx->i) {
#ifndef CUSTOM_AT_COMMAND
    perror("Ping: recv seqno unmatch"CRLF);
#endif
    return -1;
  }

  return 0;
}

LWIP_STATIC int
ping_rcv_poll(struct ping_run_ctx *ctx)
{
#if LWIP_SOCKET_POLL
  /* poll for ICMP echo response msg */
  ctx->pfd.fd = ctx->sfd;
  ctx->pfd.events = POLLIN;
  ctx->pfd.revents = 0;
  return poll(&ctx->pfd, 1, ctx->timout_ms);
#else
  /* Wait in select for ICMP response msg */
  FD_ZERO(&ctx->read_set);
  FD_SET(ctx->sfd, &ctx->read_set);
  ctx->time_val.tv_sec = ctx->timout_ms / MS_PER_SECOND;
  ctx->time_val.tv_usec = (ctx->timout_ms % MS_PER_SECOND) * US_PER_MSECOND;
  return lwip_select(ctx->sfd + 1, &ctx->read_set, 0, 0, &ctx->time_val);
#endif
}

LWIP_STATIC int
ping_rcv(struct ping_run_ctx *ctx)
{
  int ret;
  /* capture the start ms to calculate RTT */
#if LWIP_LITEOS_TASK
  ctx->start_us = hi_get_us();
#else
  ctx->start_ms = sys_now();
#endif
  ctx->timout_ms = (s32_t)ctx->timout;

  do {
    ret = ping_rcv_poll(ctx);
    if (ret < 0) {
#ifdef CUSTOM_AT_COMMAND
      (void)hi_at_printf("ping : poll/select failure"CRLF);
#else
      PRINTK("ping : poll/select failure"CRLF);
#endif
      return -1;
    } else if (ret == 0) {
      /* first type timeout event */
      break;
    }

    /* construct timeout event if poll lose efficacy when other host ping us */
    ret = recv(ctx->sfd, ctx->iphdr_resp, ctx->iecho_len + IP_HLEN_MAX, MSG_DONTWAIT);
    if (ret < 0) {
#ifdef CUSTOM_AT_COMMAND
      (void)hi_at_printf(CRLF"Recv failed ..."CRLF);
#else
      PRINTK(CRLF"Recv failed ..."CRLF);
#endif
      return -1;
    }
    ping_rcv_rtt_calc(ctx);
    ctx->timout_ms = ctx->timout - ctx->rtt;
    if (ping_rcv_check(ctx, ret) == 0) {
      ping_resp_process(ctx);
      ctx->i++;
      return 0;
    }
  } while (ctx->timout_ms > 0);

  /* all timeout events are true timeout */
  ctx->i++;
  ctx->failed_cnt++;
#ifdef CUSTOM_AT_COMMAND
  (void)hi_at_printf(CRLF"Ping: destination unreachable ..."CRLF);
#else
  PRINTK("Ping: destination unreachable ..."CRLF);
#endif
  return 0;
}

LWIP_STATIC void
ping_result_print(struct ping_run_ctx *ctx)
{
#ifdef CUSTOM_AT_COMMAND
  (void)hi_at_printf("%u packets transmitted, %u received, ", ctx->succ_cnt + ctx->failed_cnt, ctx->succ_cnt);
#if LWIP_IPV6
  if (ctx->is_v6) {
    float loss = ((float)ctx->failed_cnt * PERCENT) / (ctx->succ_cnt + ctx->failed_cnt);
    (void)hi_at_printf("%.2f%% loss", loss);
  } else
#endif
  {
    (void)hi_at_printf("%u loss", ctx->failed_cnt);
  }

  if (ctx->succ_cnt > 0) {
    s32_t rtt_ave = ctx->rtt_sum / (s32_t)ctx->succ_cnt;
    (void)hi_at_printf(", rtt min/avg/max = %d/%d/%d ms"CRLF, ctx->rtt_min, rtt_ave, ctx->rtt_max);
    (void)hi_at_printf(CRLF"OK"CRLF);
  } else {
    (void)hi_at_printf(CRLF"ERROR"CRLF);
  }
#else
  u8_t af = AF_INET;
  const char *ipstr = NULL;
  char str_buf[PING_ADDR_STR_LEN];
  const void *src = &(((struct sockaddr_in *)&ctx->to)->sin_addr);

#if LWIP_IPV6
  if (ctx->is_v6) {
    af = AF_INET6;
    src = &(((struct sockaddr_in6 *)&ctx->to)->sin6_addr);
  }
#endif
  ipstr = lwip_inet_ntop(af, src, str_buf, PING_ADDR_STR_LEN);
  if (ipstr == NULL) {
    ipstr = "****";
  }

  PRINTK(CRLF"--- %s ping statistics ---"CRLF, ipstr);
  PRINTK("%u packets transmitted, %u received, %u loss"CRLF, ctx->succ_cnt + ctx->failed_cnt,
         ctx->succ_cnt, ctx->failed_cnt);
  PRINTK(CRLF"OK"CRLF);
#endif
}

LWIP_STATIC int ping_setsockopt(struct ping_run_ctx *ctx, struct ping_cfg *cfg)
{
  int ret;
  if (cfg->src_type == LWIP_PING_HOSTNAME_ARG) {
    ret = lwip_bind(ctx->sfd, (struct sockaddr *)&cfg->src, (socklen_t)ctx->socklen);
    if (ret == -1) {
#if CUSTOM_AT_COMMAND
      (void)hi_at_printf("ping: bind icmp socket: cannot assign requested address"CRLF);
#else
      PRINTK("ping: bind icmp socket: cannot assign requested address"CRLF);
#endif
      return -1;
    }
  } else if (cfg->src_type == LWIP_PING_INTERFACE_ARG) {
    /* Binding socket to the provided netif */
    ret = lwip_setsockopt(ctx->sfd, SOL_SOCKET, SO_BINDTODEVICE, (const void *)cfg->src_iface, IFNAMSIZ);
    if (ret == -1) {
      PRINTK("ping: unknown iface %s"CRLF, cfg->src_iface);
      return -1;
    }
  }

#if LWIP_IPV6 && LWIP_SOCK_OPT_ICMP6_FILTER
  if (ctx->is_v6) {
    struct icmp6_filter icmp6_sock_filter;
    /* Setting socket filter since we are interested only in ECHO REPLY and ERROR messages */
    ICMP6_FILTER_SETBLOCKALL(&icmp6_sock_filter);
    ICMP6_FILTER_SETPASS(ICMP6_TYPE_EREP, &icmp6_sock_filter);
    ICMP6_FILTER_SETPASS(ICMP6_TYPE_DUR, &icmp6_sock_filter);
    ICMP6_FILTER_SETPASS(ICMP6_TYPE_PTB, &icmp6_sock_filter);
    ICMP6_FILTER_SETPASS(ICMP6_TYPE_TE, &icmp6_sock_filter);

    ret = lwip_setsockopt(ctx->sfd, IPPROTO_ICMPV6, ICMP6_FILTER, &icmp6_sock_filter, sizeof(struct icmp6_filter));
    if (ret == -1) {
      PRINTK("ping : setsockopt: errno %d"CRLF, errno);
      return -1;
    }
  }
#endif /* LWIP_SOCK_OPT_ICMP6_FILTER */
  return 0;
}

/* as this is not an internal function removing static keyword */
LWIP_STATIC int
os_ping_func(struct ping_cfg *cfg)
{
  struct ping_run_ctx ctx;
  int ret = -1;

  if (ping_ctx_init(&ctx, cfg) != 0) {
    mem_free(cfg);
    goto FAILURE;
  }

  if (ctx.is_v6 == 0) {
    ctx.sfd = lwip_socket(PF_INET, SOCK_RAW, IPPROTO_ICMP);
  }
#if LWIP_IPV6
  else {
    ctx.sfd = lwip_socket(PF_INET6, SOCK_RAW, IPPROTO_ICMPV6);
  }
#endif
  if (ctx.sfd < 0) {
#ifdef CUSTOM_AT_COMMAND
    (void)hi_at_printf("Ping socket create fail "CRLF);
#else
    perror("Ping socket");
#endif
    mem_free(cfg);
    goto FAILURE;
  }

  if (ping_setsockopt(&ctx, cfg) == -1) {
    mem_free(cfg);
    goto FAILURE;
  }

  mem_free(cfg);
#ifdef CUSTOM_AT_COMMAND
  if (ctx.is_v6 == 0) {
    (void)hi_at_printf("+PING:"CRLF);
  } else {
    (void)hi_at_printf("+PING6:"CRLF);
  }
#endif

  while ((ping_kill == 0) && ((ctx.forever != 0) || ((ctx.succ_cnt + ctx.failed_cnt) < ctx.cnt))) {
    ctx.iecho->seqno = htons((u16_t)ctx.i);
    ctx.iecho->chksum = 0;
    ctx.iecho->chksum = inet_chksum((void *)ctx.iecho, ctx.iecho_len);
    ret = sendto(ctx.sfd, ctx.iecho, ctx.iecho_len, 0, (struct sockaddr *)&ctx.to, (socklen_t)ctx.socklen);
    if (ret < 0) {
#ifdef CUSTOM_AT_COMMAND
      (void)hi_at_printf("Ping: sending ICMP echo request failed errno %d"CRLF, errno);
#else
      PRINTK("Ping: sending ICMP echo request failed errno %d"CRLF, errno);
#endif
      goto FAILURE;
    }

    if (ping_rcv(&ctx) != 0) {
      break;
    }
  }

  ping_result_print(&ctx);
  ret = 0;
FAILURE:
  ping_kill = 0;
  if (ctx.sfd >= 0) {
    (void)lwip_close(ctx.sfd);
  }
  if (ctx.iphdr_resp != NULL) {
    mem_free(ctx.iphdr_resp);
  }
  if (ctx.iecho != NULL) {
    mem_free(ctx.iecho);
  }
  return ret;
}

#if LWIP_LITEOS_TASK
static void
ping_cmd(unsigned int p0, unsigned int p1, unsigned int p2, unsigned int p3)
{
  union los_ptr_args ptr_args;
  struct ping_cfg *cfg = NULL;
  int ret;

  ptr_args.args[0] = p0;
  ptr_args.args[1] = p1;
  cfg = ptr_args.ptr;
  ret = os_ping_func(cfg);
  if (ret < 0) {
#ifdef CUSTOM_AT_COMMAND
    (void)hi_at_printf(CRLF"ERROR"CRLF);
#else
    PRINTK(CRLF"ERROR"CRLF);
#endif
  }

  ping_taskid = 0;
  (void)p2;
  (void)p3;
}
#endif

struct ping_cfg_handle {
  const char *key;
  u32_t *data;
  int min;
  int max;
  int arg_num;
  int (*handle)(struct ping_cfg_handle *src_handle, const char *arg);
};

LWIP_STATIC int
ping_cfg_parse_daddr(const char *daddr, struct sockaddr_storage *dst_ipaddr, u32_t is_v6)
{
  dst_ipaddr->ss_family = AF_INET;
#if LWIP_IPV6
  if (is_v6) {
    dst_ipaddr->ss_family = AF_INET6;
  }
#endif
  /* initialize dst IP address */
#if LWIP_DNS
  struct addrinfo hints_structure;
  struct addrinfo *res = NULL;

  /* Resolve the given hostname */
  hints_structure.ai_family = dst_ipaddr->ss_family;
  hints_structure.ai_flags = 0;
  if (lwip_getaddrinfo(daddr, NULL, &hints_structure, &res) != ERR_OK) {
    goto fail;
  }

#if LWIP_IPV6
  if (is_v6) {
    struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)dst_ipaddr;
    sin6->sin6_addr = ((struct sockaddr_in6 *)(res->ai_addr))->sin6_addr;
    sin6->sin6_family = AF_INET6;
    sin6->sin6_port = 0;
    sin6->sin6_scope_id = 0;
    sin6->sin6_flowinfo = 0;
  } else
#endif
  {
    struct sockaddr_in *sin = (struct sockaddr_in *)dst_ipaddr;
    sin->sin_addr = ((struct sockaddr_in *)(res->ai_addr))->sin_addr;
    sin->sin_family = AF_INET;
    sin->sin_port = 0;
  }
  lwip_freeaddrinfo(res);
#else /* LWIP_DNS */
#if LWIP_IPV6
  void *buf = is_v6 ? &(((struct sockaddr_in6 *)dst_ipaddr)->sin6_addr) :
    &(((struct sockaddr_in *)dst_ipaddr)->sin_addr);
#else
  void *buf = &(((struct sockaddr_in *)dst_ipaddr)->sin_addr);
#endif
  if (lwip_inet_pton(dst_ipaddr->ss_family, daddr, buf) != 1) {
    goto fail;
  }
#endif /* LWIP_DNS */

#if LWIP_IPV6
  if (is_v6) {
    ip6_addr_t ip6;
    inet6_addr_to_ip6addr(&ip6, &((struct sockaddr_in6 *)dst_ipaddr)->sin6_addr);
    if (ip6_addr_isany(&ip6) || ip6_addr_isnone(&ip6)) {
      goto fail;
    }
  } else
#endif
  {
    ip4_addr_t ip4;
    ip4.addr = ((struct sockaddr_in *)dst_ipaddr)->sin_addr.s_addr;
    if ((ip4.addr == IPADDR_NONE) || (ip4.addr == IPADDR_ANY)) {
      goto fail;
    }
  }
  return 0;

fail:
#if CUSTOM_AT_COMMAND
  (void)hi_at_printf("ping : Host : %s can't be resolved to IP address"CRLF, daddr);
#else
  PRINTK("ping : Host : %s can't be resolved to IP address"CRLF, daddr);
#endif
  return -1;
}

LWIP_STATIC int ping_cfg_handle_src_addr(struct ping_cfg_handle *src_handle, const char *arg)
{
  struct ping_cfg *cfg = (struct ping_cfg *)src_handle->data;
  u16_t family = AF_INET;
  void *buf = &(((struct sockaddr_in *)&cfg->src)->sin_addr);

#if LWIP_IPV6
  if (cfg->is_v6) {
    family = AF_INET6;
    buf = &(((struct sockaddr_in6 *)&cfg->src)->sin6_addr);
  }
#endif
  if (lwip_inet_pton(family, arg, buf) != 1) {
    if (strcpy_s(cfg->src_iface, IFNAMSIZ, arg) != EOK) {
      return -1;
    }

    cfg->src_type = LWIP_PING_INTERFACE_ARG;
    return 0;
  }

  struct sockaddr_in *sin = (struct sockaddr_in *)&cfg->src;
  sin->sin_family = family;
  cfg->src_type = LWIP_PING_HOSTNAME_ARG;
  return 0;
}

LWIP_STATIC int
ping_cfg_parse(int argc, const char **argv, struct ping_cfg *cfg, u32_t *ping_kill_flag)
{
  u32_t ping_forever = 0;
  u32_t i = 0;
  u32_t j = 0;
  int ret;
  struct ping_cfg_handle handle[] = {
    {
      .key = "-k",
      .data = ping_kill_flag,
      .min = 0,
      .max = INT_MAX,
      .arg_num = 0,
      .handle = NULL,
    },
    {
      .key = "-n",
      .data = &cfg->count,
      .min = 1,
      .max = INT_MAX,
      .arg_num = 1,
      .handle = NULL,
    },
    {
      .key = "-c",
      .data = &cfg->count,
      .min = 1,
      .max = INT_MAX,
      .arg_num = 1,
      .handle = NULL,
    },
    {
      .key = "-t",
      .data = &ping_forever,
      .min = 0,
      .max = INT_MAX,
      .arg_num = 0,
      .handle = NULL,
    },
    {
      .key = "-w",
      .data = &cfg->interval,
      .min = 1,
      .max = INT_MAX,
      .arg_num = 1,
      .handle = NULL,
    },
    {
      .key = "-W",
      .data = &cfg->timeout,
      .min = LWIP_SHELL_CMD_PING_TIMEOUT_MIN,
      .max = LWIP_SHELL_CMD_PING_TIMEOUT_MAX,
      .arg_num = 1,
      .handle = NULL,
    },
    {
      .key = "-l",
      .data = &cfg->data_len,
      .min = 0,
#ifndef CUSTOM_AT_COMMAND
      .max = (int)(LWIP_MAX_UDP_RAW_SEND_SIZE - sizeof(struct icmp_echo_hdr)),
#else
      .max = LWIP_PING_MAX_PKT_LEN,
#endif
      .arg_num = 1,
      .handle = NULL,
    },
    {
      .key = "-6",
      .data = &cfg->is_v6,
      .min = 0,
      .max = INT_MAX,
      .arg_num = 0,
      .handle = NULL,
    },
    {
      .key = "-I",
      .data = (u32_t *)cfg,
      .min = 0,
      .max = INT_MAX,
      .arg_num = 1,
      .handle = &ping_cfg_handle_src_addr,
    },
  };
  cfg->count = LWIP_SHELL_CMD_PING_RETRY_TIMES;
  cfg->is_v6 = 0;
  /* could add more param support */
  while (argc > 0) {
    u8_t match = 0;
    for (j = 0; j < LWIP_ARRAYSIZE(handle); j++) {
      if (strcmp(argv[i], handle[j].key) == 0) {
        if ((handle[j].arg_num + 1) > argc) {
          goto param_error;
        }

        if (handle[j].arg_num == 0) {
          *(handle[j].data) = 1;
          if (ping_kill_flag == handle[j].data) {
            return 0;
          }
        } else if (handle[j].handle != NULL) {
          ret = (*handle[j].handle)(&handle[j], argv[i + 1]);
          if (ret != 0) {
#ifdef CUSTOM_AT_COMMAND
            (void)hi_at_printf("Ping %s arg error"CRLF, handle[j].key);
#else
            PRINTK("Ping %s arg error"CRLF, handle[j].key);
#endif
            return -1;
          }
        } else {
          ret = atoi(argv[i + 1]);
          if ((ret < handle[j].min) || (ret > handle[j].max)) {
#ifdef CUSTOM_AT_COMMAND
            (void)hi_at_printf("Ping %s arg error, should be in range of [%d, %d] "CRLF,
                               handle[j].key, handle[j].min, handle[j].max);
#else
            PRINTK("Ping %s arg error, should be in range of [%d, %d] "CRLF,
                   handle[j].key, handle[j].min, handle[j].max);
#endif
            return -1;
          }
          *(handle[j].data) = (u32_t)ret;
        }
        i += handle[j].arg_num + 1;
        argc -= handle[j].arg_num + 1;
        match = 1;
        break;
      }
    }

    if (match == 0) {
      break;
    }
  }

  if (argc != 1) {
param_error:
#ifdef CUSTOM_AT_COMMAND
    (void)hi_at_printf("Invalid Ping param"CRLF);
#else
    PRINTK("Invalid Ping param"CRLF);
#endif
    return -1;
  }

  if (ping_cfg_parse_daddr(argv[i], &cfg->dst, cfg->is_v6) == -1) {
    return -1;
  }

  if (ping_forever == 1) {
    cfg->count = 0;
  }
  return 0;
}

#if LWIP_LITEOS_TASK
LWIP_STATIC u32_t ping_task_create(struct ping_cfg *cfg, u16_t prio)
{
  UINT32 los_ret;
  TSK_INIT_PARAM_S st_ping_task;
  union los_ptr_args ptr_args = {0};

  /* start one task if ping forever or ping count greater than 60 */
  if (ping_taskid > 0) {
#ifdef CUSTOM_AT_COMMAND
    (void)hi_at_printf("Ping task already running and only support one now"CRLF);
#else
    PRINTK("Ping task already running and only support one now"CRLF);
#endif
    return LOS_NOK;
  }
  ptr_args.ptr = cfg;

  st_ping_task.pfnTaskEntry = (TSK_ENTRY_FUNC)ping_cmd;
  st_ping_task.uwStackSize  = LOSCFG_BASE_CORE_TSK_DEFAULT_STACK_SIZE;
  st_ping_task.pcName = "ping_task";
  st_ping_task.usTaskPrio = prio; /* equal lwip */
  st_ping_task.uwResved = LOS_TASK_STATUS_DETACHED;
  st_ping_task.auwArgs[0] = ptr_args.args[0];
  st_ping_task.auwArgs[1] = ptr_args.args[1];
  st_ping_task.auwArgs[2] = 0;
  st_ping_task.auwArgs[3] = 0;
  los_ret = LOS_TaskCreate((UINT32 *)(&ping_taskid), &st_ping_task);
  if (los_ret != LOS_OK) {
#ifdef CUSTOM_AT_COMMAND
    (void)hi_at_printf("ping_task create failed 0x%08x."CRLF, los_ret);
#else
    PRINTK("ping_task create failed 0x%08x."CRLF, los_ret);
#endif
    return LOS_NOK;
  }
  return LOS_OK;
}
#endif

LWIP_STATIC u32_t ping_exec(struct ping_cfg *cfg)
{
#ifdef CUSTOM_AT_COMMAND
#if LWIP_LITEOS_TASK
  u32_t ret = ping_task_create(cfg, LWIP_PING_TASK_PRIO);
  if (ret != LOS_OK) {
    mem_free(cfg);
  }
  return ret;
#endif
#else
#if LWIP_LITEOS_TASK
  /* start one task if ping forever or ping count greater than 60 */
  if ((cfg->count == 0) || (cfg->count > LWIP_SHELL_CMD_PING_RETRY_TIMES)) {
    u32_t ret = ping_task_create(cfg, LWIP_PING_TASK_PRIO);
    if ((ret == LOS_NOK) || (ping_taskid == 0)) {
      PRINTK("ping_task create failed"CRLF);
      cfg->count = LWIP_SHELL_CMD_PING_RETRY_TIMES;
    } else {
      return LOS_OK;
    }
  }
#endif
  /* two cases:
   * 1, ping cout less than LWIP_SHELL_CMD_PING_RETRY_TIMES;
   * 2, ping task create failed;
   */
  if (os_ping_func(cfg) < 0) {
    PRINTK("Ping cmd failed due some errors"CRLF);
    return LOS_NOK;
  }

  return LOS_OK;
#endif
}

u32_t
os_shell_ping(int argc, const char **argv)
{
  struct ping_cfg *cfg = NULL;
  u32_t ping_kill_flag = 0;

  if (tcpip_init_finish == 0) {
#ifdef CUSTOM_AT_COMMAND
    (void)hi_at_printf("%s: tcpip_init have not been called"CRLF, __FUNCTION__);
#else
    PRINTK("%s: tcpip_init have not been called"CRLF, __FUNCTION__);
#endif
    return LOS_NOK;
  }

  cfg = mem_malloc(sizeof(struct ping_cfg));
  if (cfg == NULL) {
#ifdef CUSTOM_AT_COMMAND
    (void)hi_at_printf("%s: mem_malloc faild"CRLF, __FUNCTION__);
#else
    PRINTK("%s: mem_malloc faild"CRLF, __FUNCTION__);
#endif
    return LOS_NOK;
  }
  cfg->count = 0;
  cfg->interval = 1000; /* default ping interval */
  cfg->timeout = LWIP_SHELL_CMD_PING_TIMEOUT;
  cfg->data_len = 48; /* default data length */
  cfg->src_type = LWIP_PING_DEFAULT_SOCKET;
  cfg->is_v6 = 0;

  if ((argc < 1) || (argv == NULL)) {
#ifdef CUSTOM_AT_COMMAND
    (void)hi_at_printf("Ping: require dest ipaddr at least "CRLF);
#else
    PRINTK("Ping: require dest ipaddr at least "CRLF);
#endif
    goto ping_error;
  }
  if (ping_cfg_parse(argc, argv, cfg, &ping_kill_flag) == -1) {
    goto ping_error;
  }

  if (ping_kill_flag == 1) {
    mem_free(cfg);
    if (ping_taskid > 0) {
      ping_kill = 1; /* stop the current ping task */
#ifdef CUSTOM_AT_COMMAND
      (void)hi_at_printf("+PING%s:"CRLF"OK"CRLF, cfg->is_v6 ? "6" : "");
#endif
      return (int)LOS_OK;
    } else {
      PRINTK("No ping task running..."CRLF);
      return (int)LOS_NOK;
    }
  }

  return ping_exec(cfg);
ping_error:
  lwip_ping_usage(cfg->is_v6);
  mem_free(cfg);
  return LOS_NOK;
}

#ifdef LOSCFG_SHELL
SHELLCMD_ENTRY(ping_shellcmd, CMD_TYPE_EX, "ping", XARGS, (CmdCallBackFunc)os_shell_ping);
#endif /* LOSCFG_SHELL */

#if LWIP_IPV6
u32_t os_shell_ping6(int argc, const char **argv)
{
    int i;
    u32_t ret;
    const char **argv6 = mem_malloc(sizeof(char *) * (argc + 1));
    if (argv6 == NULL) {
#ifdef CUSTOM_AT_COMMAND
      (void)hi_at_printf("%s: mem_malloc failed"CRLF, __FUNCTION__);
#else
      PRINTK("%s: mem_malloc failed"CRLF, __FUNCTION__);
#endif
      return LOS_NOK;
    }

    argv6[0] = "-6";
    for (i = 0; i < argc; i++) {
      argv6[i + 1] = argv[i];
    }
    argc++;
    ret = os_shell_ping(argc, argv6);
    mem_free(argv6);
    return ret;
}
#ifdef LOSCFG_SHELL
SHELLCMD_ENTRY(ping6_shellcmd, CMD_TYPE_EX, "ping6", XARGS, (CmdCallBackFunc)os_shell_ping6);
#endif /* LOSCFG_SHELL */
#endif /* LWIP_IPV6 */

#endif /* LWIP_ENABLE_BASIC_SHELL_CMD */
